<!DOCTYPE html>
<html>
	<head>
		<title>Learning Hydrodynamics - WebGL</title>
		
		<script type='text/javascript' src='/js/jquery-1.10.0.min.js'></script>
		<script type='text/javascript' src='/js/util.js'></script>
		<script type='text/javascript' src='/js/gl-matrix.2.2.0.min.js'></script>
		<script type='text/javascript' src='/js/webgl-debug.js'></script>
		<script type='text/javascript' src='/js/gl-util.js'></script>
		<script type='text/javascript' src='/js/gl-util-gradient.js'></script>
		<script type='text/javascript' src='/js/gl-util-unitquad.js'></script>
		<script type='text/javascript' src='/js/gl-util-pingpong.js'></script>
		<script type='text/javascript' src='/js/mouse3d.js'></script>
		<script type='text/javascript' src='main-2d-gpu.js'></script>
		
<script type='text/javascript'>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-17312646-1']);
_gaq.push(['_trackPageview']);
(function() {
	var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
	ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
	var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
		<script id='draw-to-screen-vsh' type='x-shader/x-vertex'>
attribute vec2 vertex;
varying vec2 pos; 
uniform mat4 mvMat;
uniform mat4 projMat;
void main() {
	pos = vertex;
	gl_Position = projMat * mvMat * vec4(vertex.xy, 0., 1.);
}
		</script>
		<script id='draw-to-screen-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform sampler2D qTex;
uniform sampler2D gradientTex;
uniform float lastMin, lastMax;
void main() {
	vec4 q = texture2D(qTex, pos);
	float v = q.x;//(q.x - lastMin) / (lastMax - lastMin);
	gl_FragColor = texture2D(gradientTex, vec2(v, .5)); 
}
		</script>
		<script id='kernel-vsh' type='x-shader/x-vertex'>
attribute vec2 vertex;
varying vec2 pos;
void main() {
	pos = vertex;
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
}
		</script>
		<script id='zero-fsh' type='x-shader/x-fragment'>
void main() {
	gl_FragColor = vec4(0.);
}
		</script>
		<script id='copy-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform vec2 offset;
uniform sampler2D srcTex;
void main() {
	gl_FragColor = texture2D(srcTex, pos + offset);
}
		</script>
		<script id='reset-sod-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform sampler2D randomTex;
uniform vec2 rangeMin; 
uniform vec2 rangeMax; 
uniform float noiseAmplitude;
void main() {
	vec2 gridPos = rangeMin + pos * (rangeMax - rangeMin);
	//I would use step functions, but it's only for initialization...
	float rho;
	if (gridPos.x < (.7 * rangeMin.x + .3 * rangeMax.x) 
		&& gridPos.y < (.7 * rangeMin.y + .3 * rangeMax.y))
	{
		rho = 1.;
	} else {
		rho = .1;
	}
	vec2 vel = vec2(0., 0.);
	vel.xy += (texture2D(randomTex, pos).xy - .5) * 2. * noiseAmplitude;
	float energyKinetic = .5 * dot(vel, vel);
	float energyThermal = 1.;
	float energyTotal = energyKinetic + energyThermal;
	gl_FragColor = vec4(rho, rho * vel.xy, rho * energyTotal);
}
		</script>
		<script id='reset-wave-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform sampler2D randomTex;
uniform vec2 rangeMin; 
uniform vec2 rangeMax; 
uniform float noiseAmplitude;
void main() {
	vec2 gridPos = rangeMin + pos * (rangeMax - rangeMin);
	float dg = .2 * (rangeMax.x - rangeMin.x);
	vec2 rangeMid = .5 * (rangeMax + rangeMin);
	vec2 gridPosFromCenter = gridPos - .5 * rangeMid;
	float rho = 3. * exp(-dot(gridPosFromCenter, gridPosFromCenter) / (dg * dg)) + .1;
	vec2 vel = vec2(0., 0.);
	vel.xy += (texture2D(randomTex, pos).xy - .5) * 2. * noiseAmplitude;
	float energyKinetic = .5 * dot(vel, vel);
	float energyThermal = 1.;
	float energyTotal = energyKinetic + energyThermal;
	gl_FragColor = vec4(rho, rho * vel.xy, rho * energyTotal);
}	
		</script>
		<script id='reset-kelvin-hemholtz-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform sampler2D randomTex;
uniform vec2 rangeMin; 
uniform vec2 rangeMax; 
uniform float noiseAmplitude;
uniform float gamma;
void main() {
	vec2 gridPos = rangeMin + pos * (rangeMax - rangeMin);
	float rho = 1.;
	vec2 vel = vec2(0., 0.);
	if (gridPos.y > (.75 * rangeMin.y + .25 * rangeMax.y) && 
		gridPos.y < (.25 * rangeMin.y + .75 * rangeMax.y))
	{
		rho = 2.;
		vel.x = .5;
	}
	else
	{
		rho = 1.;
		vel.x = -.5;
	}
	vel.xy += (texture2D(randomTex, pos).xy - .5) * 2. * noiseAmplitude;
	//P = (gamma - 1) rho (eTotal - eKinetic)
	//eTotal = P / ((gamma - 1) rho) + eKinetic
	float pressure = 2.5;
	float energyKinetic = .5 * dot(vel, vel);
	float energyTotal = pressure / ((gamma - 1.) * rho) + energyKinetic; 
	gl_FragColor = vec4(rho, rho * vel.xy, rho * energyTotal);
}
		</script>
		<script id='burgers-compute-interface-velocity-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform vec2 step;
uniform sampler2D qTex;
void main() {
	vec4 q = texture2D(qTex, pos);
	vec4 qxn = texture2D(qTex, pos - step);
	vec4 qyn = texture2D(qTex, pos - step);
	gl_FragColor = vec4(
		.5 * (q.y / q.x + qxn.y / qxn.x),
		.5 * (q.z / q.x + qyn.z / qyn.x),
		0., 1.);
}
		</script>
		<script id='burgers-compute-flux-slope-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform vec2 step;
uniform sampler2D qTex;
uniform sampler2D uiTex;
void main() {
	vec2 sidestep = vec2(0.);
	sidestep[$side] = step[$side];
	vec4 qNext = texture2D(qTex, pos + sidestep);
	vec4 q = texture2D(qTex, pos);
	vec4 qPrev = texture2D(qTex, pos - sidestep);
	vec4 qPrev2 = texture2D(qTex, pos - 2.*sidestep);
	//dq = q_i,j - q_{{i,j}-dirs[side]}
	vec4 dq = q - qPrev; 
	float ui = texture2D(uiTex, pos)[$side];
	float halfSignUi = .5 * sign(ui);
	
	if (abs(dq[0]) > 0.) {
		if (ui >= 0.) {
			gl_FragColor[0] = (qPrev[0] - qPrev2[0]) / dq[0];
		} else {
			gl_FragColor[0] = (qNext[0] - q[0]) / dq[0];
		}
	} else {
		gl_FragColor[0] = 0.;
	}

	if (abs(dq[1]) > 0.) {
		if (ui >= 0.) {
			gl_FragColor[1] = (qPrev[1] - qPrev2[1]) / dq[1];
		} else {
			gl_FragColor[1] = (qNext[1] - q[1]) / dq[1];
		}
	} else {
		gl_FragColor[1] = 0.;
	}

	if (abs(dq[2]) > 0.) {
		if (ui >= 0.) {
			gl_FragColor[2] = (qPrev[2] - qPrev2[2]) / dq[2];
		} else {
			gl_FragColor[2] = (qNext[2] - q[2]) / dq[2];
		}
	} else {
		gl_FragColor[2] = 0.;
	}

	if (abs(dq[3]) > 0.) {
		if (ui >= 0.) {
			gl_FragColor[3] = (qPrev[3] - qPrev2[3]) / dq[3];
		} else {
			gl_FragColor[3] = (qNext[3] - q[3]) / dq[3];
		}
	} else {
		gl_FragColor[3] = 0.;
	}
}
		</script>
		<script id='flux-limiter-fsh' type='x-shader/x-fragment'>
vec4 fluxLimiter(vec4 r) {
	return vec4(0.);		//donorCell 
	//return vec4(1.);		//laxWendroff
	//return r;				//beamWarming
	//return .5 * (1. + r);	//fromm
/*
	//Wikipedia
	CHARM : function(r) { return Math.max(0, r*(3*r+1)/((r+1)*(r+1)) ); },
	HCUS : function(r) { return Math.max(0, 1.5 * (r + Math.abs(r)) / (r + 2) ); },
	HQUICK : function(r) { return Math.max(0, 2 * (r + Math.abs(r)) / (r + 3) ); },
	Koren : function(r) { return Math.max(0, Math.min(2*r, (1 + 2*r)/3 ,2) ); },
	minmod : function(r) { return Math.max(0, Math.min(r,1) ); },
	Oshker : function(r) { return Math.max(0, Math.min(r,1.5) ); },	//replace 1.5 with 1 <= beta <= 2	
	ospre : function(r) { return .5 * (r*r + r) / (r*r + r + 1); },
	smart : function(r) { return Math.max(0, Math.min(2 * r, .25 + .75 * r, 4)); },
	Sweby : function(r) { return Math.max(0, Math.min(1.5 * r, 1), Math.min(r, 1.5)); },	//replace 1.5 with 1 <= beta <= 2
	UMIST : function(r) { return Math.max(0, Math.min(2*r, .75 + .25*r, .25 + .75*r, 2)); },	
	vanAlbada1 : function(r) { return (r * r + r) / (r * r + 1); },
	vanAlbada2 : function(r) { return 2 * r / (r * r + 1); },
*/	
	//return (r + abs(r)) / (1. + abs(r));	//vanLeer
	//return max(vec4(0.), min(vec4(2.), min(.5 * (1. + r), 2. * r)));	//MC
	//return max(vec4(0.), max(min(vec4(1.), 2. * r), min(vec4(2.), r)));	//superbee
}	
		</script>
		<script id='burgers-compute-flux-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform vec2 step;
uniform float dt_dx;
uniform sampler2D qTex;
uniform sampler2D uiTex;
uniform sampler2D rTex;

void main() {
	vec2 sidestep = vec2(0., 0.);
	sidestep[$side] = step[$side];
	
	float ui = texture2D(uiTex, pos)[$side];
	
	vec4 qPrev = texture2D(qTex, pos - sidestep);
	vec4 q = texture2D(qTex, pos);

	if (ui >= 0.) {
		gl_FragColor = ui * qPrev;
	} else {
		gl_FragColor = ui * q;
	}
	
	vec4 r = texture2D(rTex, pos);
	vec4 phi = fluxLimiter(r);
	vec4 delta = phi * (q - qPrev);
	gl_FragColor += delta * .5 * abs(ui) * (1. - abs(ui * dt_dx));

}
		</script>
		<script id='burgers-update-state-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform vec2 step;
uniform vec2 dt_dx;
uniform sampler2D qTex;
uniform sampler2D fluxXTex;
uniform sampler2D fluxYTex;
void main() {
	vec4 q = texture2D(qTex, pos);
	vec4 fluxXL = texture2D(fluxXTex, pos);
	vec4 fluxXR = texture2D(fluxXTex, pos + vec2(step.x, 0.));
	vec4 fluxYL = texture2D(fluxYTex, pos);
	vec4 fluxYR = texture2D(fluxYTex, pos + vec2(0., step.y));

	gl_FragColor = q 
		- dt_dx.x * (fluxXR - fluxXL)
		- dt_dx.y * (fluxYR - fluxYL);
}
		</script>
		<script id='compute-pressure-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform vec2 step;
uniform float gamma;
uniform sampler2D qTex;
void main() {
	vec4 q = texture2D(qTex, pos);
	float rho = q.x;
	vec2 vel = q.yz / rho;
	float energyTotal = q.w / rho;
	float energyKinetic = .5 * dot(vel, vel);
	float energyThermal = energyTotal - energyKinetic;
	gl_FragColor = vec4(0.);
	gl_FragColor.x = (gamma - 1.) * rho * energyThermal;
}
		</script>
		<script id='apply-pressure-to-momentum-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform vec2 step;
uniform vec2 dt_dx;
uniform sampler2D qTex;
uniform sampler2D pressureTex;
void main() {
	vec2 dx = vec2(step.x, 0.);
	vec2 dy = vec2(0., step.y);
	
	vec2 posxp = pos + dx;
	vec2 posxn = pos - dx;
	vec2 posyp = pos + dy;
	vec2 posyn = pos - dy;

	float pressureXP = texture2D(pressureTex, posxp).x;
	float pressureXN = texture2D(pressureTex, posxn).x;
	float pressureYP = texture2D(pressureTex, posyp).x;
	float pressureYN = texture2D(pressureTex, posyn).x;

	gl_FragColor = texture2D(qTex, pos);
	gl_FragColor.y -= .5 * dt_dx.x * (pressureXP - pressureXN);
	gl_FragColor.z -= .5 * dt_dx.y * (pressureYP - pressureYN);
}
		</script>
		<script id='apply-pressure-to-work-fsh' type='x-shader/x-fragment'>
varying vec2 pos;
uniform vec2 step;
uniform vec2 dt_dx;
uniform sampler2D qTex;
uniform sampler2D pressureTex;
void main() {
	vec2 dx = vec2(step.x, 0.);
	vec2 dy = vec2(0., step.y);
	
	vec2 posxp = pos + dx;
	vec2 posxn = pos - dx;
	vec2 posyp = pos + dy;
	vec2 posyn = pos - dy;

	float pressureXP = texture2D(pressureTex, posxp).x;
	float pressureXN = texture2D(pressureTex, posxn).x;
	float pressureYP = texture2D(pressureTex, posyp).x;
	float pressureYN = texture2D(pressureTex, posyn).x;

	vec2 rho_u_XP = texture2D(qTex, posxp).xy;
	vec2 rho_u_XN = texture2D(qTex, posxn).xy;
	vec2 rho_v_YP = texture2D(qTex, posyp).xz;
	vec2 rho_v_YN = texture2D(qTex, posyn).xz;

	float uXP = rho_u_XP.y / rho_u_XP.x;
	float uXN = rho_u_XN.y / rho_u_XN.x;
	float vYP = rho_v_YP.y / rho_v_YP.x;
	float vYN = rho_v_YN.y / rho_v_YN.x;

	gl_FragColor = texture2D(qTex, pos);
	gl_FragColor.w -= .5 * (
		dt_dx.x * (pressureXP * uXP - pressureXN * uXN)
		+ dt_dx.y * (pressureYP * vYP - pressureYN * vYN));
}
		</script>
	
		<style type='text/css'>

body {
	background-color:black;
	color:white;
}

a:link {
	cursor:pointer;
	color:#00FFFF;
}

a:visited {
	cursor:pointer;
	color:#00FFFF;
}

a:hover {
	cursor:pointer;
	color:#00FFFF;
}

a:active {
	cursor:pointer;
	color:#00FFFF;
}
	
		</style>
	</head>
	<body style='margin:0px; overflow:hidden'>
		<div id='panel' style='overflow-x:hidden; width:400px; z-index:1, width:300px; position:absolute; background-color:rgba(0,0,0,.75)'>
			<button id='reset-sod'>Reset Sod</button><br>
			<button id='reset-wave'>Reset Wave</button><br>
			<button id='reset-kelvin-hemholtz'>Reset Kelvin-Hemholtz</button><br>
			<input id='use-noise' type='checkbox' name='useNoise' checked='true'/>Perturb Initial Velocity</input><br>
			<br>
			Boundary:
			<select id='boundary'></select><br>
			Flux Limiter:
			<select id='flux-limiter'></select><br>
			Advect:
			<select id='advect-method'></select><br>
			Color Scheme:
			<select id='color-scheme'></select><br>

			<br>
			Range:<br>
			<input id='dataRangeScaleNormalized' type='radio' group='dataRangeScale' name='dataRangeScale' disabled='true'/>Normalized Range<br>
			<input id='dataRangeScaleFixed' type='radio' group='dataRangeScale' name='dataRangeScale' checked='checked'/>Fixed Range<br>
			Min <input id='dataRangeFixedMin' value='0'/><br>
			Max <input id='dataRangeFixedMax' value='1'/><br>
			<br>
		
			<input type='radio' group='dimension' onclick='location.href="index.html"'>1D</input><br>
			<input type='radio' group='dimension' checked>2D</input><br>
		</div>
		<div id='webglfail' style='display:none'>
			Sorry, your browser does not support WebGL<br>
			Try one of these other, better browsers:<br>
			<a href='http://www.google.com/chrome'>Chrome</a><br>
			<a href='http://www.mozilla.org/firefox'>Firefox</a><br>
			<a href='http://www.apple.com/safari'>Safari</a><br>
			<b>Opera Users:</b><br>
			Enter "opera:config" in the address bar.<br>
			In the "User Prefs" section set both "Enable Hardware Acceleration" and "Enable WebGL" to "1" and then click "Save".<br>
			It is still buggy.<br>
			<b>IE Users:</b><br>
			Sorry guys, IE doesn't plan to support WebGL.<br>
			Consider using a more <a href='http://www.w3schools.com/browsers/browsers_stats.asp'>standard compliant</a> browser.<br>
		</div>
	</body>
</html>
